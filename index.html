<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR –ì—Ä–∞—Ñ—ñ–∫–∏ –§—É–Ω–∫—Ü—ñ–π</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.1/dist/mindar-image-aframe.prod.js"></script>
  
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      padding: 0; 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 50%, #db2777 100%);
      min-height: 100vh;
    }
    .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
    .text-center { text-align: center; }
    .mb-2 { margin-bottom: 8px; }
    .mb-4 { margin-bottom: 16px; }
    .mb-6 { margin-bottom: 24px; }
    .mb-8 { margin-bottom: 32px; }
    .gap-4 { gap: 16px; }
    
    .card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 24px;
    }
    
    .title {
      font-size: 2.25rem;
      font-weight: bold;
      color: white;
    }
    
    .subtitle {
      color: rgba(216, 180, 254, 1);
      font-size: 1rem;
    }
    
    .section-title {
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
    }
    
    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    }
    
    .function-card {
      padding: 16px;
      border-radius: 8px;
      transition: all 0.3s;
      cursor: pointer;
    }
    
    .function-card:hover {
      transform: scale(1.05);
    }
    
    .function-card.selected {
      background: rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 0 4px white;
    }
    
    .function-card.available {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .function-card.available:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .color-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
    }
    
    .flex {
      display: flex;
    }
    
    .flex-wrap {
      flex-wrap: wrap;
    }
    
    .items-center {
      align-items: center;
    }
    
    .justify-between {
      justify-content: space-between;
    }
    
    .justify-center {
      justify-content: center;
    }
    
    .function-name {
      font-size: 1.25rem;
      font-weight: bold;
      color: white;
    }
    
    .function-formula {
      font-size: 1.125rem;
      font-family: monospace;
      color: rgba(216, 180, 254, 1);
    }
    
    .function-desc {
      font-size: 0.875rem;
      color: rgba(216, 180, 254, 1);
    }
    
    .btn {
      padding: 16px 32px;
      border-radius: 12px;
      font-weight: bold;
      font-size: 1.125rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    .btn:hover:not(:disabled) {
      transform: scale(1.05);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    }
    
    .btn-primary {
      background: linear-gradient(to right, #4ade80, #3b82f6);
    }
    
    .btn:disabled {
      background: #6b7280;
      color: #d1d5db;
      cursor: not-allowed;
    }
    
    .btn-small {
      padding: 8px 16px;
      font-size: 1rem;
    }
    
    .btn-red {
      background: #ef4444;
    }
    
    .btn-red:hover {
      background: #dc2626;
    }
    
    .btn-purple {
      background: #a855f7;
    }
    
    .btn-purple:hover {
      background: #9333ea;
    }
    
    .btn-green {
      background: #22c55e;
    }
    
    .btn-green:hover {
      background: #16a34a;
    }
    
    .info-box {
      background: rgba(234, 179, 8, 0.2);
      border-radius: 12px;
      padding: 24px;
      color: white;
    }
    
    .info-title {
      font-size: 1.25rem;
      font-weight: bold;
      margin-bottom: 12px;
    }
    
    .info-list {
      list-style-position: inside;
      list-style-type: decimal;
    }
    
    .info-list li {
      margin-bottom: 8px;
    }
    
    .ui-overlay { 
      position: fixed; 
      z-index: 1000; 
      pointer-events: none; 
    }
    
    .ui-overlay > * { 
      pointer-events: auto; 
    }
    
    #ar-container { 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
    }
    
    .hidden { 
      display: none; 
    }
    
    .ar-header {
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.9), transparent);
      padding: 16px;
    }
    
    .ar-footer {
      background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
      padding: 24px;
    }
    
    .formula-panel {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 8px;
      padding: 16px;
      max-width: 28rem;
      margin: 0 auto;
    }
    
    .formula-item {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .formula-item:last-child {
      border-bottom: none;
    }
    
    .formula-item-title {
      font-size: 1.125rem;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    .formula-item-formula {
      font-family: monospace;
      font-size: 0.875rem;
      color: white;
      margin-bottom: 4px;
    }
    
    .formula-item-desc {
      font-size: 0.75rem;
      color: #9ca3af;
    }
    
    .controls {
      max-width: 64rem;
      margin: 0 auto;
    }
    
    .control-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }
    
    .control-item {
      flex: 1;
      min-width: 200px;
    }
    
    .slider-container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      border-radius: 12px;
      padding: 12px;
    }
    
    .slider-label {
      font-size: 0.875rem;
      margin-bottom: 8px;
      display: block;
      color: white;
    }
    
    .slider {
      width: 100%;
    }
    
    .status-indicator {
      backdrop-filter: blur(5px);
      padding: 12px 24px;
      border-radius: 9999px;
      font-size: 0.875rem;
      text-align: center;
      color: white;
      font-weight: bold;
      transition: all 0.3s;
    }
    
    .status-found {
      background: #22c55e;
    }
    
    .status-searching {
      background: #f97316;
    }
    
    .tips {
      margin-top: 8px;
      text-align: center;
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.8);
      background: rgba(0, 0, 0, 0.4);
      border-radius: 8px;
      padding: 8px;
    }

    .coef-controls {
      background: rgba(0, 0, 0, 0.7);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }

    .coef-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .coef-label {
      color: white;
      font-size: 0.875rem;
      min-width: 80px;
    }

    .coef-input {
      flex: 1;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .marker-info {
      background: rgba(59, 130, 246, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
      color: white;
      font-size: 0.875rem;
    }
  </style>
</head>
<body>
  <div id="menu-view"></div>
  <div id="ar-container" class="hidden"></div>
  <div id="ar-ui" class="hidden"></div>  
    <!-- A-Frame Scene -->
    <a-scene mindar-image="imageTargetSrc: ./targets.mind; maxTrack: 2;"
             vr-mode-ui="enabled: false"
             device-orientation-permission-ui="enabled: false"
             quadrilateral-calculator>
        
        <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
        
        <!-- –ú–∞—Ä–∫–µ—Ä sin (targetIndex: 0) -->
        <a-entity id="sin-marker" mindar-image-target="targetIndex: 0">
            <a-sphere color="#e74c3c" radius="0.1" position="0 0.1 0"></a-sphere>
            <a-text value="sin" position="0 0.3 0" align="center" color="#e74c3c" scale="2 2 2"></a-text>
        </a-entity>
        
        <!-- –ú–∞—Ä–∫–µ—Ä paraboloid (targetIndex: 1) -->
        <a-entity id="paraboloid-marker" mindar-image-target="targetIndex: 1">
            <a-sphere color="#3498db" radius="0.1" position="0 0.1 0"></a-sphere>
            <a-text value="paraboloid-marker" position="0 0.3 0" align="center" color="#3498db" scale="2 2 2"></a-text>
        </a-entity>
        
        <!-- –ú–∞—Ä–∫–µ—Ä saddle (targetIndex: 2) -->
        <a-entity id="saddle-marker" mindar-image-target="targetIndex: 2">
            <a-sphere color="#9b59b6" radius="0.1" position="0 0.1 0"></a-sphere>
            <a-text value="saddle" position="0 0.3 0" align="center" color="#9b59b6" scale="2 2 2"></a-text>
        </a-entity>
        
        <!-- –ú–∞—Ä–∫–µ—Ä waves (targetIndex: 3) -->
        <a-entity id="waves-marker" mindar-image-target="targetIndex: 3">
            <a-sphere color="#f1c40f" radius="0.1" position="0 0.1 0"></a-sphere>
            <a-text value="waves" position="0 0.3 0" align="center" color="#f1c40f" scale="2 2 2"></a-text>
        </a-entity>

        <!-- –ú–∞—Ä–∫–µ—Ä cone (targetIndex: 4) -->
        <a-entity id="cone-marker" mindar-image-target="targetIndex: 3">
            <a-sphere color="#f1c40f" radius="0.1" position="0 0.1 0"></a-sphere>
            <a-text value="cone" position="0 0.3 0" align="center" color="#f1c40f" scale="2 2 2"></a-text>
        </a-entity>

        <!-- –ú–∞—Ä–∫–µ—Ä gaussian (targetIndex: 5) -->
        <a-entity id="gaussian-marker" mindar-image-target="targetIndex: 3">
            <a-sphere color="#f1c40f" radius="0.1" position="0 0.1 0"></a-sphere>
            <a-text value="gaussian" position="0 0.3 0" align="center" color="#f1c40f" scale="2 2 2"></a-text>
        </a-entity>
        
    </a-scene>
  <script>
    const functions = [
      { 
        id: 'sin', 
        targetIndex: 0,
        name: '–°–∏–Ω—É—Å', 
        formula: 'f(x,y) = a¬∑sin(b¬∑‚àö(x¬≤+y¬≤)) + c', 
        color: '#ff6b6b', 
        description: '–†–∞–¥—ñ–∞–ª—å–Ω—ñ —Ö–≤–∏–ª—ñ'
      },
      { 
        id: 'paraboloid', 
        targetIndex: 1,
        name: '–ü–∞—Ä–∞–±–æ–ª–æ—ó–¥', 
        formula: 'f(x,y) = a¬∑(b¬∑x¬≤ + c¬∑y¬≤)', 
        color: '#4ecdc4', 
        description: '–ß–∞—à–∞ –ø–∞—Ä–∞–±–æ–ª–∏'
      },
      { 
        id: 'saddle', 
        targetIndex: 2,
        name: '–°—ñ–¥–ª–æ', 
        formula: 'f(x,y) = a¬∑(b¬∑x¬≤ - c¬∑y¬≤)', 
        color: '#45b7d1', 
        description: '–ì—ñ–ø–µ—Ä–±–æ–ª—ñ—á–Ω–µ —Å—ñ–¥–ª–æ'
      },
      { 
        id: 'cone', 
        targetIndex: 3,
        name: '–ö–æ–Ω—É—Å', 
        formula: 'f(x,y) = a¬∑‚àö(x¬≤+y¬≤) + c', 
        color: '#f9ca24', 
        description: '–†–∞–¥—ñ–∞–ª—å–Ω—ñ —Ö–≤–∏–ª—ñ'
      },
      { 
        id: 'waves', 
        targetIndex: 4,
        name: '–•–≤–∏–ª—ñ', 
        formula: 'f(x,y) = a¬∑sin(b¬∑x)¬∑cos(c¬∑y)', 
        color: '#a29bfe', 
        description: '–ü–µ—Ä–µ—Ö—Ä–µ—Å–Ω—ñ —Ö–≤–∏–ª—ñ'
      },
      { 
        id: 'gaussian', 
        targetIndex: 5,
        name: '–ì–∞—É—Å—ñ–∞–Ω', 
        formula: 'f(x,y) = a¬∑e^(-(b¬∑x¬≤ + c¬∑y¬≤))', 
        color: '#fd79a8', 
        description: '–î–∑–≤—ñ–Ω –ì–∞—É—Å–∞'
      },
      { 
        id: 'linear', 
        targetIndex: 6,
        name: '–õ—ñ–Ω—ñ–π–Ω–∞', 
        formula: 'y = a¬∑x + b', 
        color: '#00d2ff', 
        description: '2D –ª—ñ–Ω—ñ–π–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è',
        marker: 'hiro',
        markerImageUrl: 'https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.png',
        is2D: true
      },
      { 
        id: 'quadratic', 
        targetIndex: 7,
        name: '–ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–∞', 
        formula: 'y = a¬∑x¬≤ + b¬∑x + c', 
        color: '#ff6348', 
        description: '2D –ø–∞—Ä–∞–±–æ–ª–∞',
        marker: 'hiro',
        markerImageUrl: 'https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.png',
        is2D: true
      }
    ];

    window.arState = {
      selectedFunctions: [],
      isSimulating: false,
      rotationSpeed: 1,
      showFormulas: true,
      markerVisible: {},
      coefficients: {}
    };

    const defaultCoefficients = {
      'sin': { a: 1, b: 1, c: 0 },
      'paraboloid': { a: 1, b: 1, c: 1 },
      'saddle': { a: 1, b: 1, c: 1 },
      'cone': { a: 1, b: 1, c: 1 },
      'waves': { a: 1, b: 2, c: 2 },
      'gaussian': { a: 1, b: 1.5, c: 1.5 },
      'linear': { a: 1, b: 0, c: 0 },
      'quadratic': { a: 1, b: 0, c: 0 }
    };

    functions.forEach(func => {
      window.arState.coefficients[func.id] = defaultCoefficients[func.id] || { a: 1, b: 1, c: 0 };
      window.arState.markerVisible[func.id] = false;
    });

    AFRAME.registerComponent('parametric-surface', {
      schema: {
        funcType: { type: 'string', default: 'sin' },
        color: { type: 'color', default: '#ff6b6b' },
        coefA: { type: 'number', default: 1 },
        coefB: { type: 'number', default: 1 },
        coefC: { type: 'number', default: 1 }
      },

      init: function () {
        this.createMesh();
      },

      update: function(oldData) {
        if (oldData.coefA !== this.data.coefA || 
            oldData.coefB !== this.data.coefB || 
            oldData.coefC !== this.data.coefC ||
            oldData.funcType !== this.data.funcType ||
            oldData.color !== this.data.color) {
          this.createMesh();
        }
      },

      createMesh: function() {
        const funcType = this.data.funcType;
        const color = this.data.color;
        const a = this.data.coefA;
        const b = this.data.coefB;
        const c = this.data.coefC;
        
        let calculateFunc;
        switch(funcType) {
          case 'sin': 
            calculateFunc = (x, y) => a * Math.sin(b * Math.sqrt(x*x + y*y)) + c; 
            break;
          case 'paraboloid': 
            calculateFunc = (x, y) => a * (b * x*x + c * y*y) * 0.2; 
            break;
          case 'saddle': 
            calculateFunc = (x, y) => a * (b * x*x - c * y*y) * 0.2; 
            break;
          case 'cone': 
            calculateFunc = (x, y) => {
              const r = Math.sqrt(x*x + y*y);
              return a * Math.sqrt((b*x*x + c*y*y) / (r*r || 1));
            };
            break;
          case 'waves': 
            calculateFunc = (x, y) => a * (Math.sin(b * x) * Math.cos(c * y)); 
            break;
          case 'gaussian': 
            const sigma = 1.5;
            calculateFunc = (x, y) => a * Math.exp(-((b * x*x + c * y*y) / (2 * sigma * sigma))); 
            break;
          default: 
            calculateFunc = (x, y) => a * Math.sin(b * Math.sqrt(x*x + y*y)) + c;
        }

        const segments = 40;
        const size = 1.5;
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const colors = [];
        const hexColor = new THREE.Color(color);

        for (let i = 0; i <= segments; i++) {
          for (let j = 0; j <= segments; j++) {
            const x = (i / segments - 0.5) * size;
            const y = (j / segments - 0.5) * size;
            const z = calculateFunc(x * 3, y * 3);
            
            vertices.push(x, z * 0.5, y);
            
            const intensity = Math.abs(z) * 0.5 + 0.5;
            colors.push(
              hexColor.r * intensity,
              hexColor.g * intensity,
              hexColor.b * intensity
            );
          }
        }

        for (let i = 0; i < segments; i++) {
          for (let j = 0; j < segments; j++) {
            const a = i * (segments + 1) + j;
            const b = a + segments + 1;
            indices.push(a, b, a + 1);
            indices.push(b, b + 1, a + 1);
          }
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();

        const material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          side: THREE.DoubleSide,
          shininess: 60,
          transparent: true,
          opacity: 0.85
        });

        const mesh = new THREE.Mesh(geometry, material);
        
        if (this.mesh) {
          this.el.removeObject3D('mesh');
        }
        
        this.el.setObject3D('mesh', mesh);
        this.mesh = mesh;
      },

      tick: function(time, timeDelta) {
        if (this.mesh && window.arState && window.arState.isSimulating) {
          this.mesh.rotation.z += window.arState.rotationSpeed * 0.01;
        }
      }
    });

    AFRAME.registerComponent('graph-2d', {
      schema: {
        funcType: { type: 'string', default: 'linear' },
        color: { type: 'color', default: '#00d2ff' },
        coefA: { type: 'number', default: 1 },
        coefB: { type: 'number', default: 0 },
        coefC: { type: 'number', default: 0 }
      },

      init: function () {
        this.createGraph();
      },

      update: function(oldData) {
        if (oldData.coefA !== this.data.coefA || 
            oldData.coefB !== this.data.coefB || 
            oldData.coefC !== this.data.coefC ||
            oldData.funcType !== this.data.funcType ||
            oldData.color !== this.data.color) {
          this.createGraph();
        }
      },

      createGraph: function() {
        const funcType = this.data.funcType;
        const color = this.data.color;
        const a = this.data.coefA;
        const b = this.data.coefB;
        const c = this.data.coefC;

        let calculateFunc;
        switch(funcType) {
          case 'linear': 
            calculateFunc = (x) => a * x + b;
            break;
          case 'quadratic': 
            calculateFunc = (x) => a * x * x + b * x + c;
            break;
          default: 
            calculateFunc = (x) => a * x + b;
        }

        const points = [];
        const segments = 100;
        const range = 3;

        for (let i = 0; i <= segments; i++) {
          const x = (i / segments - 0.5) * range * 2;
          const y = calculateFunc(x);
          points.push(new THREE.Vector3(x * 0.3, y * 0.3, 0));
        }

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ 
          color: new THREE.Color(color),
          linewidth: 3
        });

        const line = new THREE.Line(geometry, material);

        const axesGroup = new THREE.Group();

        const xAxisGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(-1, 0, 0),
          new THREE.Vector3(1, 0, 0)
        ]);
        const xAxis = new THREE.Line(xAxisGeom, new THREE.LineBasicMaterial({ color: 0xffffff }));
        axesGroup.add(xAxis);

        const yAxisGeom = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, -1, 0),
          new THREE.Vector3(0, 1, 0)
        ]);
        const yAxis = new THREE.Line(yAxisGeom, new THREE.LineBasicMaterial({ color: 0xffffff }));
        axesGroup.add(yAxis);

        const mainGroup = new THREE.Group();
        mainGroup.add(line);
        mainGroup.add(axesGroup);

        if (this.mesh) {
          this.el.removeObject3D('mesh');
        }

        this.el.setObject3D('mesh', mainGroup);
        this.mesh = mainGroup;
      }
    });

    function setState(newState) {
      window.arState = { ...window.arState, ...newState };
      render();
    }

    function setCoefficient(funcId, coef, value) {
      window.arState.coefficients[funcId][coef] = parseFloat(value);
      updateSurface(funcId);
    }

    function updateSurface(funcId) {
      const entity = document.querySelector(`#surface-${funcId}`);
      if (entity) {
        const func = functions.find(f => f.id === funcId);
        const coefs = window.arState.coefficients[funcId];

        if (func.is2D) {
          entity.setAttribute('graph-2d', {
            funcType: funcId,
            color: func.color,
            coefA: coefs.a,
            coefB: coefs.b,
            coefC: coefs.c
          });
        } else {
          entity.setAttribute('parametric-surface', {
            funcType: funcId,
            color: func.color,
            coefA: coefs.a,
            coefB: coefs.b,
            coefC: coefs.c
          });
        }
      }
    }

    function toggleFunction(funcId) {
      if (window.arState.selectedFunctions.includes(funcId)) {
        setState({ selectedFunctions: window.arState.selectedFunctions.filter(id => id !== funcId) });
      } else {
        setState({ selectedFunctions: [...window.arState.selectedFunctions, funcId] });
      }
    }

    function startAR() {
      const selectedFuncs = functions.filter(f => window.arState.selectedFunctions.includes(f.id));
      if (selectedFuncs.length === 0) return;

      const container = document.getElementById('ar-container');
      container.classList.remove('hidden');
      
      let sceneHTML = `
        <a-scene mindar-image="imageTargetSrc: ./targets.mind; maxTrack: 8;"
                 vr-mode-ui="enabled: false"
                 device-orientation-permission-ui="enabled: false">
          <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      `;

      selectedFuncs.forEach((func) => {
        const coefs = window.arState.coefficients[func.id];
  
        if (func.is2D) {
          sceneHTML += `
            <a-entity id="marker-${func.id}" mindar-image-target="targetIndex: ${func.targetIndex}">
              <a-entity position="0 0 0" rotation="-90 0 0" scale="1.2 1.2 1.2">
                <a-entity id="surface-${func.id}" graph-2d="funcType: ${func.id}; color: ${func.color}; coefA: ${coefs.a}; coefB: ${coefs.b}; coefC: ${coefs.c}"></a-entity>
                <a-plane position="0 0 -0.1" rotation="0 0 0" width="2" height="2" color="#222222" opacity="0.2"></a-plane>
              </a-entity>
            </a-entity>
          `;
        } else {
          sceneHTML += `
            <a-entity id="marker-${func.id}" mindar-image-target="targetIndex: ${func.targetIndex}">
              <a-entity position="0 0 0" rotation="-90 0 0" scale="0.8 0.8 0.8">
                <a-entity id="surface-${func.id}" parametric-surface="funcType: ${func.id}; color: ${func.color}; coefA: ${coefs.a}; coefB: ${coefs.b}; coefC: ${coefs.c}"></a-entity>
                <a-plane position="0 0 -0.3" rotation="0 0 0" width="1.5" height="1.5" color="#333333" opacity="0.3"></a-plane>
              </a-entity>
            </a-entity>
          `;
        }
      });

      sceneHTML += `</a-scene>`;
      container.innerHTML = sceneHTML;

      setTimeout(() => {
        selectedFuncs.forEach(func => {
          const marker = document.querySelector(`#marker-${func.id}`);
          if (marker) {
            marker.addEventListener('targetFound', () => {
              window.arState.markerVisible[func.id] = true;
              console.log(`‚úÖ Marker ${func.name} found`);
              renderARUI();
            });
            
            marker.addEventListener('targetLost', () => {
              window.arState.markerVisible[func.id] = false;
              console.log(`‚ùå Marker ${func.name} lost`);
              renderARUI();
            });
          }
        });

        document.getElementById('menu-view').classList.add('hidden');
        document.getElementById('ar-ui').classList.remove('hidden');
        renderARUI();
      }, 500);
    }

    function stopAR() {
      const container = document.getElementById('ar-container');
      container.innerHTML = '';
      container.classList.add('hidden');
      
      document.getElementById('ar-ui').classList.add('hidden');
      document.getElementById('menu-view').classList.remove('hidden');
      
      Object.keys(window.arState.markerVisible).forEach(key => {
        window.arState.markerVisible[key] = false;
      });
      
      setState({ isSimulating: false });
    }

    function renderMenu() {
      const selectedFuncs = window.arState.selectedFunctions;

      return `
        <div class="container">
          <div class="text-center mb-8">
            <h1 class="title mb-2">üìä AR –ì—Ä–∞—Ñ—ñ–∫–∏ –§—É–Ω–∫—Ü—ñ–π</h1>
            <p class="subtitle">–¢—Ä–∏–≤–∏–º—ñ—Ä–Ω—ñ –º–∞—Ç–µ–º–∞—Ç–∏—á–Ω—ñ –≥—Ä–∞—Ñ—ñ–∫–∏ —É –¥–æ–ø–æ–≤–Ω–µ–Ω—ñ–π —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—ñ</p>
          </div>

          <div class="card mb-6">
            <h2 class="section-title mb-4">–û–±–µ—Ä—ñ—Ç—å —Ñ—É–Ω–∫—Ü—ñ—ó</h2>

            <div class="grid">
              ${functions.map(func => {
                const isSelected = selectedFuncs.includes(func.id);
                const cardClass = isSelected ? 'selected' : 'available';
                const coefs = window.arState.coefficients[func.id];
                
                return `
                  <div class="function-card ${cardClass}" onclick="toggleFunction('${func.id}')">
                    <div class="flex items-center gap-3 mb-2">
                      <div class="color-dot" style="background-color: ${func.color};"></div>
                      <h3 class="function-name">${func.name}</h3>
                    </div>
                    <p class="function-formula mb-2">${func.formula}</p>
                    <p class="function-desc mb-2">${func.description}</p>
                    <div class="marker-info">
                      üîñ –ú–∞—Ä–∫–µ—Ä: ${func.targetIndex}
                    </div>
                    ${isSelected ? `
                      <div class="coef-controls" onclick="event.stopPropagation()">
                        <div class="coef-row">
                          <span class="coef-label">a =</span>
                          <input type="number" step="0.1" value="${coefs.a}" 
                            class="coef-input"
                            onchange="setCoefficient('${func.id}', 'a', event.target.value); setState({});" />
                        </div>
                        <div class="coef-row">
                          <span class="coef-label">b =</span>
                          <input type="number" step="0.1" value="${coefs.b}" 
                            class="coef-input"
                            onchange="setCoefficient('${func.id}', 'b', event.target.value); setState({});" />
                        </div>
                        <div class="coef-row">
                          <span class="coef-label">c =</span>
                          <input type="number" step="0.1" value="${coefs.c}" 
                            class="coef-input"
                            onchange="setCoefficient('${func.id}', 'c', event.target.value); setState({});" />
                        </div>
                      </div>
                    ` : ''}
                  </div>
                `;
              }).join('')}
            </div>
          </div>

          <div class="flex gap-4 justify-center flex-wrap mb-6">
            <button class="btn ${selectedFuncs.length > 0 ? 'btn-primary' : ''}" 
              onclick="startAR()"
              ${selectedFuncs.length === 0 ? 'disabled' : ''}>
              üì∑ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ AR
            </button>
          </div>

          <div class="info-box">
            <h3 class="info-title">üí° –Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó:</h3>
            <ol class="info-list">
              <li>–û–±–µ—Ä—ñ—Ç—å –æ–¥–Ω—É –∞–±–æ –¥–µ–∫—ñ–ª—å–∫–∞ —Ñ—É–Ω–∫—Ü—ñ–π</li>
              <li>–ù–∞–ª–∞—à—Ç—É–π—Ç–µ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç–∏ a, b, c –¥–ª—è –∫–æ–∂–Ω–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó</li>
              <li>–ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—å, —â–æ —É –≤–∞—Å —î —Ñ–∞–π–ª targets.mind –∑ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–∏–º–∏ –º–∞—Ä–∫–µ—Ä–∞–º–∏</li>
              <li>–ù–∞—Ç–∏—Å–Ω—ñ—Ç—å "–ó–∞–ø—É—Å—Ç–∏—Ç–∏ AR"</li>
              <li>–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏</li>
              <li>–ù–∞–≤–µ–¥—ñ—Ç—å –∫–∞–º–µ—Ä—É –Ω–∞ –º–∞—Ä–∫–µ—Ä–∏</li>
              <li>–ö–æ–∂–µ–Ω –≥—Ä–∞—Ñ—ñ–∫ –∑'—è–≤–∏—Ç—å—Å—è –Ω–∞–¥ —Å–≤–æ—ó–º –º–∞—Ä–∫–µ—Ä–æ–º —É 3D –ø—Ä–æ—Å—Ç–æ—Ä—ñ</li>
              <li>–ü—Ä–∏ –ø–æ–∫–∞–∑—É–≤–∞–Ω–Ω—ñ –¥–µ–∫—ñ–ª—å–∫–æ—Ö –º–∞—Ä–∫–µ—Ä—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ –≥—Ä–∞—Ñ—ñ–∫–∏ –Ω–∞–∫–ª–∞–¥—É—Ç—å—Å—è</li>
            </ol>
          </div>
        </div>
      `;
    }

    function renderARUI() {
      const selectedFuncs = functions.filter(f => window.arState.selectedFunctions.includes(f.id));
      const arUI = document.getElementById('ar-ui');
      
      const anyMarkerVisible = Object.values(window.arState.markerVisible).some(v => v);
      const visibleMarkers = Object.keys(window.arState.markerVisible).filter(k => window.arState.markerVisible[k]);
      
      arUI.innerHTML = `
        <div class="ui-overlay ar-header" style="top: 0; left: 0; right: 0;">
          <div class="flex justify-between items-center flex-wrap gap-4">
            <button class="btn btn-small btn-red" onclick="stopAR()">
              ‚Üê –ù–∞–∑–∞–¥
            </button>
            <div class="text-center">
              <h2 class="section-title">AR –°–∏–º—É–ª—è—Ü—ñ—è</h2>
              <p style="font-size: 0.875rem; color: #d1d5db;">${selectedFuncs.map(f => f.name).join(' + ')}</p>
            </div>
            <button class="btn btn-small btn-purple" onclick="setState({ showFormulas: !window.arState.showFormulas }); renderARUI();">
              ${window.arState.showFormulas ? 'üìΩ' : 'üìº'} –§–æ—Ä–º—É–ª–∏
            </button>
          </div>
        </div>

        ${window.arState.showFormulas ? `
          <div class="ui-overlay" style="top: 80px; left: 16px; right: 16px;">
            <div class="formula-panel">
              ${selectedFuncs.map(func => {
                const coefs = window.arState.coefficients[func.id];
                const isVisible = window.arState.markerVisible[func.id];
                return `
                  <div class="formula-item" style="opacity: ${isVisible ? 1 : 0.5}">
                    <h3 class="formula-item-title" style="color: ${func.color};">
                      ${func.name} ${isVisible ? '‚úî' : ''}
                    </h3>
                    <p class="formula-item-formula">${func.formula}</p>
                    <p class="formula-item-desc">${func.description}</p>
                    <p class="formula-item-desc">a=${coefs.a}, b=${coefs.b}, c=${coefs.c}</p>
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        ` : ''}

        <div class="ui-overlay ar-footer" style="bottom: 0; left: 0; right: 0;">
          <div class="controls">
            <div class="control-row">
              <div class="control-item">
                <button class="btn ${window.arState.isSimulating ? 'btn-red' : 'btn-green'}" 
                  style="width: 100%;"
                  onclick="setState({ isSimulating: !window.arState.isSimulating }); renderARUI();">
                  ${window.arState.isSimulating ? '‚è∏Ô∏è –ó—É–ø–∏–Ω–∏—Ç–∏' : '‚ñ∂Ô∏è –ü–æ—á–∞—Ç–∏'} –æ–±–µ—Ä—Ç–∞–Ω–Ω—è
                </button>
              </div>

              <div class="control-item slider-container">
                <label class="slider-label">–®–≤–∏–¥–∫—ñ—Å—Ç—å: ${window.arState.rotationSpeed}x</label>
                <input type="range" class="slider" min="0.5" max="3" step="0.5" value="${window.arState.rotationSpeed}"
                  oninput="setState({ rotationSpeed: parseFloat(event.target.value) }); renderARUI();" />
              </div>
            </div>

            <div class="status-indicator ${anyMarkerVisible ? 'status-found' : 'status-searching'}">
              ${anyMarkerVisible ? 
                `‚úÖ –ó–Ω–∞–π–¥–µ–Ω–æ –º–∞—Ä–∫–µ—Ä–∏: ${visibleMarkers.map(id => functions.find(f => f.id === id).name).join(', ')}` : 
                'üéØ –®—É–∫–∞—î–º–æ –º–∞—Ä–∫–µ—Ä–∏... –ù–∞–≤–µ–¥—ñ—Ç—å –∫–∞–º–µ—Ä—É –Ω–∞ —Ä–æ–∑–¥—Ä—É–∫–æ–≤–∞–Ω—ñ –º–∞—Ä–∫–µ—Ä–∏'
              }
            </div>
            
            <div class="tips">
              üí° –ü–æ—Ä–∞–¥–∏: –≥–∞—Ä–Ω–µ –æ—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è ‚Ä¢ –≤—ñ–¥—Å—Ç–∞–Ω—å 20-50 —Å–º ‚Ä¢ –º–∞—Ä–∫–µ—Ä–∏ —Ä—ñ–≤–Ω–æ —É –∫–∞–¥—Ä—ñ ‚Ä¢ –º–æ–∂–Ω–∞ –ø–æ–∫–∞–∑—É–≤–∞—Ç–∏ –¥–µ–∫—ñ–ª—å–∫–∞ –º–∞—Ä–∫–µ—Ä—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ
            </div>
          </div>
        </div>
      `;
    }

    function render() {
      const menuView = document.getElementById('menu-view');
      menuView.innerHTML = renderMenu();
    }

    render();
  </script>
</body>
</html>
